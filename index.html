<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<meta name="author" content="Luciano Rodrigues Lucio Neto">
<title>Resolução dos exercícios de PDI</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Resolução dos exercícios de PDI</h1>
<div class="details">
<span id="author" class="author">Luciano Rodrigues Lucio Neto</span><br>
<span id="email" class="email"><a href="mailto:lucianorlneto@gmail.com">lucianorlneto@gmail.com</a></span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Sumário</div>
<ul class="sectlevel1">
<li><a href="#_observação">Observação</a></li>
<li><a href="#_1_seção_3_manipulando_em_pixels_em_em_uma_imagem">1. Seção 3: Manipulando <em>pixels</em> em uma imagem</a>
<ul class="sectlevel2">
<li><a href="#_1_1_exercício_1">1.1 Exercício 1</a></li>
<li><a href="#_1_2_exercício_2">1.2 Exercício 2</a></li>
</ul>
</li>
<li><a href="#_2_seção_4_preenchendo_regiões">2. Seção 4: Preenchendo regiões</a>
<ul class="sectlevel2">
<li><a href="#_2_1_exercício_1">2.1 Exercício 1</a></li>
<li><a href="#_2_2_exercício_2">2.2 Exercício 2</a></li>
</ul>
</li>
<li><a href="#_3_seção_5_manipulação_de_histogramas">3. Seção 5: Manipulação de histogramas</a>
<ul class="sectlevel2">
<li><a href="#_3_1_exercício_1">3.1 Exercício 1</a></li>
<li><a href="#_3_2_exercício_2">3.2 Exercício 2</a></li>
</ul>
</li>
<li><a href="#_4_seção_6_filtragem_no_domínio_espacial_i">4. Seção 6: Filtragem no domínio espacial I</a>
<ul class="sectlevel2">
<li><a href="#_4_1_exercício">4.1 Exercício</a></li>
</ul>
</li>
<li><a href="#_5_seção_7_filtragem_no_domínio_espacial_ii">5. Seção 7: Filtragem no domínio espacial II</a>
<ul class="sectlevel2">
<li><a href="#_5_1_exercício_1">5.1 Exercício 1</a></li>
<li><a href="#_5_2_exercício_2">5.2 Exercício 2</a></li>
</ul>
</li>
<li><a href="#_6_seção_8_filtragem_no_domínio_da_frequência">6. Seção 8: Filtragem no domínio da frequência</a>
<ul class="sectlevel2">
<li><a href="#_6_1_exercício">6.1 Exercício</a></li>
</ul>
</li>
<li><a href="#_7_seção_11_canny_e_a_arte_com_pontilhismo">7. Seção 11: Canny e a arte com pontilhismo</a>
<ul class="sectlevel2">
<li><a href="#_7_1_exercício">7.1 Exercício</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_observação">Observação</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Todos os exercícios são propostos no tutorial de OpenCV feito pelo professor Agostinho, UFRN, <a href="http://agostinhobritojr.github.io/tutoriais/pdi/" class="bare">http://agostinhobritojr.github.io/tutoriais/pdi/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_1_seção_3_manipulando_em_pixels_em_em_uma_imagem">1. Seção 3: Manipulando <em>pixels</em> em uma imagem</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_1_1_exercício_1">1.1 Exercício 1</h3>
<div class="paragraph">
<p>Utilizando o programa exemplos/<em>pixels</em>.cpp como referência, implemente um programa regions.cpp. Esse programa deverá solicitar ao usuário as coordenadas de dois pontos P1 e P2 localizados dentro dos limites do tamanho da imagem e exibir que lhe for fornecida. Entretanto, a região definida pelo retângulo de vértices opostos definidos pelos pontos P1P1 e P2P2 será exibida com o negativo da imagem na região correspondente. O efeito é ilustrado na Figura Regiões.</p>
</div>
<div class="sect3">
<h4 id="_resolução">Resolução</h4>
<div class="paragraph">
<p>Para calcularmos o negativo de uma deteminada área retangular, passamos quatro parametros de entrada para o programa e, dentro dessa área determinada, fazemos,
para uma imagem em tons de cinza, 255 - x, onde x é a cor da imagem num determinado <em>pixel</em>.<br>
Abaixo temos o código:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="listingblock">
<div class="title">regions.cpp</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;cv.h&gt;
#include &lt;highgui.h&gt;

using namespace cv;
using namespace std;

struct ponto{
  int x, y;
};

int main(int argc, char** argv){
  Mat image;

  ponto p1, p2;

  if(argv[1] == NULL || argv[2] == NULL || argv[3] == NULL || argv[4] == NULL){
    cout &lt;&lt; "\nPasse as coordenadas dos pontos p1 e p2. Ex.: 130 140 20 100\n";
    exit(1);
  }


  p1.x = atoi(argv[1]);
  p1.y = atoi(argv[2]);
  p2.x = atoi(argv[3]);
  p2.y = atoi(argv[4]);

  image= imread("biel.png",CV_LOAD_IMAGE_GRAYSCALE);
  if(!image.data)
    cout &lt;&lt; "nao abriu biel.png" &lt;&lt; endl;

  namedWindow("janela",WINDOW_AUTOSIZE);

  for(int i=p1.x;i&lt;p1.y;i++){
    for(int j=p2.x;j&lt;p2.y;j++){
      image.at&lt;uchar&gt;(i,j)= 255 - image.at&lt;uchar&gt;(i,j);
    }
  }

  imshow("janela", image);
  waitKey();

  return 0;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Os resultados são mostrados abaixo:
<span class="image"><img src="https://raw.githubusercontent.com/Lucianorlneto/lucianorlneto.github.io/master/exercicio%203.1%20(regions).png" alt="exercicio%203.1%20(regions)"></span></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_1_2_exercício_2">1.2 Exercício 2</h3>
<div class="paragraph">
<p>Utilizando o programa exemplos/<em>pixels</em>.cpp como referência, implemente um programa trocaregioes.cpp. Seu programa deverá trocar os quadrantes em diagonal na imagem. Explore o uso da classe Mat e seus construtores para criar as regiões que serão trocadas. O efeito é ilustrado na Figura Troca de regiões.</p>
</div>
<div class="sect3">
<h4 id="_resolução_2">Resolução</h4>
<div class="paragraph">
<p>Para trocar as regiões da imagem, foram utilizados métodos do OpenCv que capturam um retangulo determinado por dois pontos e o copia para uma certa área de uma imagem.
Os métodos foram Rect e copyTo como pode-se ver no código abaixo:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="listingblock">
<div class="title">trocaregioes.cpp</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;cv.h&gt;
#include &lt;highgui.h&gt;

using namespace cv;
using namespace std;

struct ponto{
  int x, y;
};

int main(int argc, char** argv){
  Mat image;

  image= imread("biel.png",CV_LOAD_IMAGE_GRAYSCALE);
  if(!image.data)
    cout &lt;&lt; "nao abriu biel.png" &lt;&lt; endl;

  namedWindow("janela",WINDOW_AUTOSIZE);

  Size tamanho = image.size();

  Mat final = image.clone();

  Mat copia1(image, Rect(0,0, tamanho.height/2, tamanho.width/2));
  Mat copia2(image, Rect(tamanho.width/2,0, tamanho.height/2, tamanho.width/2));
  Mat copia3(image, Rect(0,tamanho.height/2,tamanho.height/2,tamanho.width/2));
  Mat copia4(image, Rect(tamanho.height/2,tamanho.width/2, tamanho.height/2, tamanho.width/2));

  copia4.copyTo(final(Rect(0,0, tamanho.height/2, tamanho.width/2)));
  copia1.copyTo(final(Rect(tamanho.height/2,tamanho.width/2, tamanho.height/2, tamanho.width/2)));
  copia2.copyTo(final(Rect(0,tamanho.height/2,tamanho.height/2,tamanho.width/2)));
  copia3.copyTo(final(Rect(tamanho.width/2,0, tamanho.height/2, tamanho.width/2)));

  namedWindow("janela2", WINDOW_AUTOSIZE);

  imshow("janela", image);
  imshow("janela2", final);
  waitKey();

  return 0;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Abaixo temos o resultado em uma imagem:
<span class="image"><img src="https://raw.githubusercontent.com/Lucianorlneto/lucianorlneto.github.io/master/exercicio%20trocaregioes.png" alt="exercicio%20trocaregioes"></span></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_2_seção_4_preenchendo_regiões">2. Seção 4: Preenchendo regiões</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_2_1_exercício_1">2.1 Exercício 1</h3>
<div class="paragraph">
<p>Observando-se o programa labeling.cpp como exemplo, é possível verificar que caso existam mais de 255 objetos na cena, o processo de rotulação poderá ficar comprometido. Identifique a situação em que isso ocorre e proponha uma solução para este problema.</p>
</div>
<div class="sect3">
<h4 id="_resolução_3">Resolução</h4>
<div class="paragraph">
<p>Existem várias soluções para o problema. Uma delas é utilizar mais que 8 bits para a quantidade de tons de cinza, porém, dessa maneira, sempre haverá limitação para o número de objetos na imagem. Outra solução é, se a imagem possuir cor de <em>background</em> fixa, pode-se, assim que for encontrada uma cor diferente da do <em>background</em>, preencher aquele espaço diferente com a cor de fundo da imagem e contar +1 para cada operação similar.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_2_2_exercício_2">2.2 Exercício 2</h3>
<div class="paragraph">
<p>Aprimore o algoritmo de contagem apresentado para identificar regiões com ou sem buracos internos que existam na cena. Assuma que objetos com mais de um buraco podem existir. Inclua suporte no seu algoritmo para não contar bolhas que tocam as bordas da imagem. Não se pode presumir, a priori, que elas tenham buracos ou não.</p>
</div>
<div class="sect3">
<h4 id="_resolução_4">Resolução</h4>
<div class="paragraph">
<p>Primeiro é necessário varrer os <em>pixels</em> das bordas e, se houver algum objeto, preenche-lo da mesma cor do <em>background</em>, tirando objetos da borda da imagem. Após isso, é pintado o fundo da imagem para uma cor diferente da cor dos buracos dos objetos. Com esse tratamento, identifica-se os objetos com buracos verificando os <em>pixels</em> pretos. Para desconsiderar mais de um buraco em um bojeto, pois um buraco já determina aquele objeto como "objeto com buraco", preenchemos toda a parte branca do objeto de preto, assim que for encontrado um <em>pixel</em> de cor preta. Fazendo isso se tem o número de objetos com buraco. Depois desse passo, teremos a imagem com objetos completamente pretos (objeto com buraco) e completamente brancos (objeto sem buraco), então podemos utilizar o método de <em>labeling</em> descrito na seção para contarmos o número de objetos sem buraco.<br>
Para fazer esse preenchemento de cor de um conjunto de <em>pixels</em> vizinhos de mesma cor, é utilizada a função do OpenCv floodFill como pode-se ver no código abaixo:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="listingblock">
<div class="title">buracos.cpp</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

int main(int argc, char** argv){
  Mat image, mask, image2;
  int width, height;
  int ObjetosComBuracos = 0;
  int ObjetosSemBuracos = 0;

  CvPoint p;
  image = imread(argv[1],CV_LOAD_IMAGE_GRAYSCALE);

  if(!image.data){
    std::cout &lt;&lt; "imagem nao carregou corretamente\n";
    return(-1);
  }
  width=image.size().width;
  height=image.size().height;

  imshow("image", image);

  //tira os objetos das bordas
  for(int i=0; i&lt;width; i++){
    p.x = i;
    p.y = 0;
    if(image.at&lt;uchar&gt;(p.y,p.x) == 255)
      floodFill(image, p, 0);
  }

  for(int i=0; i&lt;width; i++){
    p.x = i;
    p.y = height-1;
    if(image.at&lt;uchar&gt;(p.y,p.x) == 255)
      floodFill(image, p, 0);
  }

  for(int i=0; i&lt;height; i++){
    p.x = 0;
    p.y = i;
    if(image.at&lt;uchar&gt;(p.y,p.x) == 255)
      floodFill(image, p, 0);
    p.x = width-1;
    p.y = i;
    if(image.at&lt;uchar&gt;(p.y,p.x) == 255)
      floodFill(image, p, 0);
  }

  //pinta o fundo
  p.x=0;
  p.y=0;
  floodFill(image, p, 100);

  imshow("image2", image);


  //conta objetos com buracos
  for(int i=0; i&lt;height; i++){
    for(int j=1; j&lt;width; j++){
      if(image.at&lt;uchar&gt;(i,j) == 0){
    // achou um objeto
    p.x=j-1;
    p.y=i;
    if(image.at&lt;uchar&gt;(p.y,p.x) == 255)
      floodFill(image,p,0);
       }
   }
  }
  imshow("image3", image);
  for(int i=0; i&lt;height; i++){
    for(int j=0; j&lt;width; j++){
      if(image.at&lt;uchar&gt;(i,j) == 0){
    // achou um objeto
    ObjetosComBuracos++;
    p.x=j;
    p.y=i;
    floodFill(image,p,ObjetosComBuracos);
      }
    }
  }
  cout &lt;&lt; "Numero de objetos com buracos: " &lt;&lt; ObjetosComBuracos &lt;&lt; endl;

  imshow("image4", image);

  for(int i=0; i&lt;height; i++){
    for(int j=0; j&lt;width; j++){
      if(image.at&lt;uchar&gt;(i,j) == 255){
    // achou um objeto
    ObjetosSemBuracos++;
    p.x=j;
    p.y=i;
    floodFill(image,p,ObjetosSemBuracos);
      }
    }
  }
  cout &lt;&lt; "Numero de objetos sem buracos: " &lt;&lt; ObjetosSemBuracos &lt;&lt; endl;
  cout &lt;&lt; "Numero de objetos no total: " &lt;&lt; ObjetosComBuracos + ObjetosSemBuracos &lt;&lt; endl;

  imshow("image5", image);
  imwrite("labeling.png", image);
  waitKey();
  return 0;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Como resultado, mostrando passo a passo das operações, temos o seguinte:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/Lucianorlneto/lucianorlneto.github.io/master/exercicio%20buracos.png" alt="exercicio%20buracos"></span></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_3_seção_5_manipulação_de_histogramas">3. Seção 5: Manipulação de histogramas</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_3_1_exercício_1">3.1 Exercício 1</h3>
<div class="paragraph">
<p>Utilizando o programa exemplos/histogram.cpp como referência, implemente um programa equalize.cpp. Este deverá, para cada imagem capturada, realizar a equalização do histogram antes de exibir a imagem. Teste sua implementação apontando a câmera para ambientes com iluminações variadas e observando o efeito gerado. Assuma que as imagens processadas serão em tons de cinza.</p>
</div>
<div class="sect3">
<h4 id="_resolução_5">Resolução</h4>
<div class="paragraph">
<p>A partir do exemplo dado na seção 5 do tutorial, apenas são feitas as alterações necessárias para converter as imagens da câmera para tons de cinza e, após isso, utilzar a função equalizeHist() do OpenCv para calcular a equalização do histograma da imagem original e gerar uma nova imagem equalizada. No programa, como é visto abaixo, são apresentadas duas imagens. Uma original em tons de cinza e a outra equalizada para facilitar na comparação entre as duas.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="listingblock">
<div class="title">equalize.cpp</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

int main(int argc, char** argv){
  Mat image;
  int width, height;
  VideoCapture cap;
  Mat plane;
  Mat hist, histeq, histG, histB;
  int nbins = 64;
  float range[] = {0, 256};
  const float *histrange = { range };
  bool uniform = true;
  bool acummulate = false;

  cap.open(0);

  if(!cap.isOpened()){
    cout &lt;&lt; "cameras indisponiveis";
    return -1;
  }

  width  = cap.get(CV_CAP_PROP_FRAME_WIDTH);
  height = cap.get(CV_CAP_PROP_FRAME_HEIGHT);

  cout &lt;&lt; "largura = " &lt;&lt; width &lt;&lt; endl;
  cout &lt;&lt; "altura  = " &lt;&lt; height &lt;&lt; endl;

  int histw = nbins, histh = nbins/2;
  Mat histImg(histh, histw, CV_8UC1, Scalar(0));
  Mat histImgeq(histh, histw, CV_8UC1, Scalar(0));
  Mat gray, eq;

  while(1){
    cap &gt;&gt; image;
    cvtColor(image, gray, CV_BGR2GRAY);
    equalizeHist(gray, eq);
    //split (image, planes);
    calcHist(&amp;gray, 1, 0, Mat(), hist, 1,
             &amp;nbins, &amp;histrange,
             uniform, acummulate);
    calcHist(&amp;eq, 1, 0, Mat(), histeq, 1,
              &amp;nbins, &amp;histrange,
              uniform, acummulate);


    normalize(hist, hist, 0, histImg.rows, NORM_MINMAX, -1, Mat());
    normalize(histeq, histeq, 0, histImgeq.rows, NORM_MINMAX, -1, Mat());



    histImg.setTo(Scalar(0));
    histImgeq.setTo(Scalar(0));


    for(int i=0; i&lt;nbins; i++){
      line(histImg,
           Point(i, histh),
           Point(i, histh-cvRound(hist.at&lt;float&gt;(i))),
           Scalar(255, 255, 255), 1, 8, 0);
      line(histImgeq,
           Point(i, histh),
           Point(i, histh-cvRound(histeq.at&lt;float&gt;(i))),
           Scalar(255, 255, 255), 1, 8, 0);

    }
    histImg.copyTo(gray(Rect(0, 0       ,nbins, histh)));
    histImgeq.copyTo(eq(Rect(0, 0       ,nbins, histh)));


    //imshow("histograma", histImgR);
    imshow("imagem equalizada", eq);
    imshow("image", gray);
    if(waitKey(30) &gt;= 0) break;
  }
  return 0;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Os resultados podem ser vistos na seguinte imagem:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/Lucianorlneto/lucianorlneto.github.io/master/exercicio%20equalize.png" alt="exercicio%20equalize"></span></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_3_2_exercício_2">3.2 Exercício 2</h3>
<div class="paragraph">
<p>Utilizando o programa exemplos/histogram.cpp como referência, implemente um programa motiondetector.cpp. Este deverá continuamente calcular o histograma da imagem (apenas uma componente de cor é suficiente) e compará-lo com o último histograma calculado. Quando a diferença entre estes ultrapassar um limiar pré-estabelecido, ative um alarme. Utilize uma função de comparação que julgar conveniente.</p>
</div>
<div class="sect3">
<h4 id="_resolução_6">Resolução</h4>
<div class="paragraph">
<p>O método que foi implementada para detecção de movimento no programa fonte abaixo foi o seguinte: guarda-se, em um acumulador, a soma de todos os tons de cinza dos pixels de um frame anterior da câmera e, em outro acumulador, a soma de todos os tons do frame atual. Com esses dois valores, podemos identificar se um frame é igual ou semelhante ao anterior. Se essa diferenã for maior que um limiar determinado, quer dizer que a imagem se difere mais do que o valor desejável, caracterizando um movimento de um frame para o outro.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="listingblock">
<div class="title">motiondetector.cpp</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

int main(int argc, char** argv){
  Mat image;
  int width, height;
  VideoCapture cap;
  bool flag = false;
  long int soma_anterior, soma;

  cap.open(0);

  if(!cap.isOpened()){
    cout &lt;&lt; "cameras indisponiveis";
    return -1;
  }

  width  = cap.get(CV_CAP_PROP_FRAME_WIDTH);
  height = cap.get(CV_CAP_PROP_FRAME_HEIGHT);

  cout &lt;&lt; "largura = " &lt;&lt; width &lt;&lt; endl;
  cout &lt;&lt; "altura  = " &lt;&lt; height &lt;&lt; endl;

  Mat gray;

  soma_anterior = 0;
  soma = 0;

  while(1){
    if(flag == false){
      cout &lt;&lt; "feifjie" &lt;&lt; endl;
      cap &gt;&gt; image;
      cvtColor(image, gray, CV_BGR2GRAY);

      for(int i=0; i&lt;width; i++){
        for (int j = 0; j &lt; height; ++j)
        {
          soma_anterior += gray.at&lt;uchar&gt;(i,j);
        }
      }
      //imshow("histograma", histImgR);
      imshow("image", gray);
      flag = true;

      if(waitKey(30) &gt;= 0) break;
    }else{
      cap &gt;&gt; image;
      cvtColor(image, gray, CV_BGR2GRAY);

      for(int i=0; i&lt;width; i++){
        for (int j = 0; j &lt; height; ++j)
        {
          soma+= gray.at&lt;uchar&gt;(i,j);
        }
      }

      long int limiar = soma - soma_anterior;

      //cout &lt;&lt; "limiar = " &lt;&lt; limiar &lt;&lt; endl;

      if(limiar &lt; -700000 || limiar &gt; 700000){
        cout &lt;&lt; "\n\nMovimento detectado!\n\n";
      }

      //imshow("histograma", histImgR);
      imshow("image", gray);
      soma_anterior = soma;
      soma = 0;
      if(waitKey(30) &gt;= 0) break;
    }





  }
  return 0;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>O resultado pode ser visto nas duas imagens abaixo:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/Lucianorlneto/lucianorlneto.github.io/master/md1.png" alt="md1"></span><br>
<span class="image"><img src="https://raw.githubusercontent.com/Lucianorlneto/lucianorlneto.github.io/master/md2.png" alt="md2"></span></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_4_seção_6_filtragem_no_domínio_espacial_i">4. Seção 6: Filtragem no domínio espacial I</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_4_1_exercício">4.1 Exercício</h3>
<div class="paragraph">
<p>Utilizando o programa exemplos/filtroespacial.cpp como referência, implemente um programa laplgauss.cpp. O programa deverá acrescentar mais uma funcionalidade ao exemplo fornecido, permitindo que seja calculado o laplaciano do gaussiano das imagens capturadas. Compare o resultado desse filtro com a simples aplicação do filtro laplaciano.</p>
</div>
<div class="sect3">
<h4 id="_resolução_7">Resolução</h4>
<div class="paragraph">
<p>A partir do exemplo presente na seção 6 do tutorial, adiciona-se um novo array para uma matriz 5x5 com a máscara do laplaciano do gaussiano e, ao detectar que a tecla k foi pressionada, o programa filtra a imagem com a máscara do LoG.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="listingblock">
<div class="title">laplgauss.cpp</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

void printmask(Mat &amp;m){
  for(int i=0; i&lt;m.size().height; i++){
    for(int j=0; j&lt;m.size().width; j++){
      cout &lt;&lt; m.at&lt;float&gt;(i,j) &lt;&lt; ",";
    }
    cout &lt;&lt; endl;
  }
}

void menu(){
  cout &lt;&lt; "\npressione a tecla para ativar o filtro: \n"
  "a - calcular modulo\n"
    "m - media\n"
    "g - gauss\n"
    "v - vertical\n"
  "h - horizontal\n"
    "l - laplaciano\n"
    "k - LoG (Laplaciano do Gaussiano)\n"
  "esc - sair\n";
}

int main(int argvc, char** argv){
  VideoCapture video;
  float media[] = {1,1,1,
           1,1,1,
           1,1,1};
  float gauss[] = {1,2,1,
           2,4,2,
           1,2,1};
  float horizontal[]={-1,0,1,
            -2,0,2,
            -1,0,1};
  float vertical[]={-1,-2,-1,
          0,0,0,
          1,2,1};
  float laplacian[]={0,-1,0,
           -1,4,-1,
           0,-1,0};
  float log[] = {0, 0, -1, 0, 0,
                 0, -1, -2, -1, 0,
                  -1, -2, 16, -2, -1,
                  0, -1, -2, -1, 0,
                  0, 0, -1, 0, 0};

  Mat cap, frame, frame32f, frameFiltered;
  Mat mask(3,3,CV_32F), mask1, mask2;
  Mat result, result1;
  double width, height, min, max;
  int absolut;
  char key;

  video.open(0);
  if(!video.isOpened())
    return -1;
  width=video.get(CV_CAP_PROP_FRAME_WIDTH);
  height=video.get(CV_CAP_PROP_FRAME_HEIGHT);
  std::cout &lt;&lt; "largura=" &lt;&lt; width &lt;&lt; "\n";;
  std::cout &lt;&lt; "altura =" &lt;&lt; height&lt;&lt; "\n";;

  namedWindow("filtroespacial",1);

  mask = Mat(3, 3, CV_32F, media);
  scaleAdd(mask, 1/9.0, Mat::zeros(3,3,CV_32F), mask1);
  swap(mask, mask1);
  absolut=1; // calcs abs of the image

  menu();
  for(;;){
    video &gt;&gt; cap;
    cvtColor(cap, frame, CV_BGR2GRAY);
    flip(frame, frame, 1);
    imshow("original", frame);
    frame.convertTo(frame32f, CV_32F);
    filter2D(frame32f, frameFiltered, frame32f.depth(), mask, Point(1,1), 0);
    if(absolut){
      frameFiltered=abs(frameFiltered);
    }
    frameFiltered.convertTo(result, CV_8U);
    imshow("filtroespacial", result);
    key = (char) waitKey(10);
    if( key == 27 ) break; // esc pressed!
    switch(key){
    case 'a':
    menu();
      absolut=!absolut;
      break;
    case 'm':
    menu();
      mask = Mat(3, 3, CV_32F, media);
      scaleAdd(mask, 1/9.0, Mat::zeros(3,3,CV_32F), mask1);
      mask = mask1;
      printmask(mask);
      break;
    case 'g':
    menu();
      mask = Mat(3, 3, CV_32F, gauss);
      scaleAdd(mask, 1/16.0, Mat::zeros(3,3,CV_32F), mask1);
      mask = mask1;
      printmask(mask);
      break;
    case 'h':
    menu();
      mask = Mat(3, 3, CV_32F, horizontal);
      printmask(mask);
      break;
    case 'v':
    menu();
      mask = Mat(3, 3, CV_32F, vertical);
      printmask(mask);
      break;
    case 'l':
    menu();
      mask = Mat(3, 3, CV_32F, laplacian);
      printmask(mask);
      break;
    case 'k':
      mask = Mat(5, 5, CV_32F, log);
      printmask(mask);
    default:
      break;
    }
  }
  return 0;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Abaixo, na imagem, se vê como o filtro atua na imagem original.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/Lucianorlneto/lucianorlneto.github.io/master/exercicio%20log.png" alt="exercicio%20log"></span></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_5_seção_7_filtragem_no_domínio_espacial_ii">5. Seção 7: Filtragem no domínio espacial II</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_5_1_exercício_1">5.1 Exercício 1</h3>
<div class="paragraph">
<p>Utilizando o programa exemplos/addweighted.cpp como referência, implemente um programa tiltshift.cpp. Três ajustes deverão ser providos na tela da interface:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>um ajuste para regular a altura da região central que entrará em foco;<br></p>
</li>
<li>
<p>um ajuste para regular a força de decaimento da região borrada;<br></p>
</li>
<li>
<p>um ajuste para regular a posição vertical do centro da região que entrará em foco. Finalizado o programa, a imagem produzida deverá ser salva em arquivo.<br></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_resolução_8">Resolução</h4>
<div class="paragraph">
<p>Para fazer o <em>tiltshift</em>, é preciso criar duas imagens de ponderação do tamanho da imagem que se queira trabalhar onde, em uma se tem uma imagem em tons de cinza que faz dois gradientes a partir de uma função (presenta na seção do tutorial) que gera qual tom de cinza estará naquele pixel e, na outra imagem, o negativo dessa primeira. Após serem feitas as imagens para ponderação, aplicamos um filtro para borramento, com média entre 12 imagens da imagem que se deseja apicar o efeito tiltshift. Com a primeira imagem de ponderação, é feita uma multiplicação pixel a pixel com a imagem primária e, com a imagem primária. Pós filtro de borramento, é feita a mesma multiplicação com o negativo da imagem de ponderação e, para ser feita a imagem final, com o efeito tiltshift, basta utilizar a função do OpenCv addWeighted para fazer a soma das duas imagens multiplicadas e formar a iamgem resultado com o efeito aplicado. Os parâmetros da função alpha que gera os valores de tom de cinza dos pixels das imagens de ponderação são passados por <em>trackbars</em>. Após completar as modificações, basta clicar qualquer tecla para, antes do programa fechar, a imagem modificada ser salva. A implementação pode ser vista no código abaixo:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="listingblock">
<div class="title">tiltshift.cpp</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;math.h&gt;

using namespace cv;
using namespace std;

int d_slider = 1;
int d_slider_max = 100;
int l1_slider = 1;
int l1_slider_max;
int l2_slider = 1;
int l2_slider_max;

int top_slider = 0;
int top_slider_max = 100;

Mat image1, image2, blended;
Mat imageTop;

int teste;

char TrackbarName[50];

int width, height;
int d, l1, l2;
Mat p1, p2, dst1, dst2, resultado, dst, src;

float alpha(int x, int d, int l1, int l2){
  double alpha = (float)255*(float)1/(float)2*((float)tanh(((float)x-(float)l1)/(float)d)-(float)tanh(((float)x-(float)l2)/(float)d));
  return alpha;

}

void on_trackbar_d(int, void*){
 d = d_slider;
 for (int i = 0; i &lt; height; ++i)
  {
    for (int j = 0; j &lt; width; ++j)
    {
      p1.at&lt;uchar&gt;(i, j) = alpha(i, d, l1, l2);
    }
  }

  for (int i = 0; i &lt; height; ++i)
  {
    for (int j = 0; j &lt; width; ++j)
    {
      p2.at&lt;uchar&gt;(i, j) = 255 - p1.at&lt;uchar&gt;(i, j);
    }
  }
  cvtColor(p1, p1, CV_GRAY2RGB);
  cvtColor(p2, p2, CV_GRAY2RGB);

  multiply(src, p1, dst1, 1.0, CV_16U);
  multiply(dst, p2, dst2, 1.0, CV_16U);

 addWeighted(dst1, 1 , dst2, 1, 100.0, resultado);
 imshow("tiltshift", resultado);
 imshow("ponderacao 1", p1);
 imshow("ponderacao 2", p2);

  cvtColor(p1, p1, CV_RGB2GRAY);
  cvtColor(p2, p2, CV_RGB2GRAY);
}

void on_trackbar_l1(int, void*){
 l1 = l1_slider;
 for (int i = 0; i &lt; height; ++i)
  {
    for (int j = 0; j &lt; width; ++j)
    {
      p1.at&lt;uchar&gt;(i, j) = alpha(i, d, l1, l2);
    }
  }

  for (int i = 0; i &lt; height; ++i)
  {
    for (int j = 0; j &lt; width; ++j)
    {
      p2.at&lt;uchar&gt;(i, j) = 255 - p1.at&lt;uchar&gt;(i, j);
    }
  }
  cvtColor(p1, p1, CV_GRAY2RGB);
  cvtColor(p2, p2, CV_GRAY2RGB);

  multiply(src, p1, dst1, 1.0, CV_16U);
  multiply(dst, p2, dst2, 1.0, CV_16U);

 addWeighted(dst1, 1 , dst2, 1, 100.0, resultado);
 imshow("tiltshift", resultado);
  imshow("ponderacao 1", p1);
 imshow("ponderacao 2", p2);

  cvtColor(p1, p1, CV_RGB2GRAY);
  cvtColor(p2, p2, CV_RGB2GRAY);
}

void on_trackbar_l2(int, void*){
 l2 = l2_slider+height/2;
 for (int i = 0; i &lt; height; ++i)
  {
    for (int j = 0; j &lt; width; ++j)
    {
      p1.at&lt;uchar&gt;(i, j) = alpha(i, d, l1, l2);
    }
  }

  for (int i = 0; i &lt; height; ++i)
  {
    for (int j = 0; j &lt; width; ++j)
    {
      p2.at&lt;uchar&gt;(i, j) = 255 - p1.at&lt;uchar&gt;(i, j);
    }
  }
  cvtColor(p1, p1, CV_GRAY2RGB);
  cvtColor(p2, p2, CV_GRAY2RGB);

  multiply(src, p1, dst1, 1.0, CV_16U);
  multiply(dst, p2, dst2, 1.0, CV_16U);

 addWeighted(dst1, 1 , dst2, 1, 100.0, resultado);
 imshow("tiltshift", resultado);
  imshow("ponderacao 1", p1);
 imshow("ponderacao 2", p2);

  cvtColor(p1, p1, CV_RGB2GRAY);
  cvtColor(p2, p2, CV_RGB2GRAY);
}

int main(int argvc, char** argv){

  teste = 5;

  cout &lt;&lt; teste &lt;&lt; endl;

  src = imread("basketgame.jpg");

  width=src.size().width;
  height=src.size().height;

  d = 50;
  l1 = height/4;
  l2 = 3*height/4;

  l1_slider_max = height/2;
  l2_slider_max = height/2;

  cout &lt;&lt; l1 &lt;&lt; endl &lt;&lt; l2 &lt;&lt; endl;



  Mat p11(height, width, CV_8UC1);
  Mat p12(height, width, CV_8UC1);

  p1 = p11.clone();
  p2 = p12.clone();

  for ( int i = 1; i &lt; 9; i = i + 2 )
    {
      medianBlur ( src, dst, i );
    }

  src.copyTo(imageTop);
  namedWindow("tiltshift", 1);

  sprintf( TrackbarName, "d x %d", d_slider_max );
  createTrackbar( TrackbarName, "tiltshift",
          &amp;d_slider,
          d_slider_max,
          on_trackbar_d );
  on_trackbar_d(d_slider, 0 );
  sprintf( TrackbarName, "l1 x %d", l1_slider_max );
  createTrackbar( TrackbarName, "tiltshift",
          &amp;l1_slider,
          l1_slider_max,
          on_trackbar_l1 );
  on_trackbar_l1(l1_slider, 0 );
  sprintf( TrackbarName, "l2 x %d", l2_slider_max );
  createTrackbar( TrackbarName, "tiltshift",
          &amp;l2_slider,
          l2_slider_max,
          on_trackbar_l2 );
  on_trackbar_l2(l2_slider, 0 );

  waitKey(0);

  imwrite("imagem_resultado.png", resultado);

  return 0;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>O resultado da implementação pode ser visto na imagem que segue onde é mostrado a imagem resultante com os parametros determinados nas <em>trackbars</em> e as imagens de ponderação geradas por aqueles parâmetros:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/Lucianorlneto/lucianorlneto.github.io/master/exercicio%20tiltshift.png" alt="exercicio%20tiltshift"></span></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_5_2_exercício_2">5.2 Exercício 2</h3>
<div class="paragraph">
<p>Utilizando o programa exemplos/addweighted.cpp como referência, implemente um programa tiltshiftvideo.cpp. Tal programa deverá ser capaz de processar um arquivo de vídeo, produzir o efeito de tilt-shift nos quadros presentes e escrever o resultado em outro arquivo de vídeo. A ideia é criar um efeito de miniaturização de cenas. Descarte quadros em uma taxa que julgar conveniente para evidenciar o efeito de stop motion, comum em vídeos desse tipo.</p>
</div>
<div class="sect3">
<h4 id="_resolução_9">Resolução</h4>
<div class="paragraph">
<p>Para aplicar o efeito tiltshift em um vídeo, foi utilizado o mesmo algoritmo da questão anterior, porém , dependendo da resolução e quantidade de repetições do mesmo frame para o cálculo da média (<em>blur</em>), o vídeo começa a ser processado de forma muito lenta, ou seja, a forma como foi implementado o programa mostrado a seguir é inviável para aplicação do efeito tiltshift ao vivo enquanto o vídeo é reproduzido. Uma das formas que esse problema pode ser resolvido é processando o vídeo e armazenando em um novo arquivo de vídeo, tendo assim o vídeo completo com o efeito aplicado sem ver o vídeo travando ao processar o efeito enquanto é reproduzido. O <em>blur</em> é feito com 9 imagens e a função de cálculo das imagens de ponderação tem parâmetros d = 30, l1 = 1/4 do frame e l2 = 3/4 do frame.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="listingblock">
<div class="title">tiltshiftvideo.cpp</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">  #include &lt;iostream&gt;
  #include &lt;opencv2/opencv.hpp&gt;
  #include &lt;math.h&gt;

  using namespace cv;
  using namespace std;

  int width, height;
  int d, l1, l2;
  Mat p1, p2, dst1, dst2, resultado, frame_borrado, frame;
  VideoCapture cap, video;

  float alpha(int x, int d, int l1, int l2){
    double alpha = (float)255*(float)1/(float)2*((float)tanh(((float)x-(float)l1)/(float)d)-(float)tanh(((float)x-(float)l2)/(float)d));
    return alpha;

  }

  int main(int argvc, char** argv){


    video.open("megaman.mp4");

    video &gt;&gt; frame;

    width  = frame.size().width;
    height = frame.size().height;

    d = 30;
    l1 = height/4;
    l2 = 3*height/4;

    Mat p11(height, width, CV_8UC1);
    Mat p12(height, width, CV_8UC1);

    p1 = p11.clone();
    p2 = p12.clone();

    cout &lt;&lt; width&lt;&lt; endl &lt;&lt; height &lt;&lt; endl;
    cout &lt;&lt; p1.size().width &lt;&lt; endl &lt;&lt; p1.size().height &lt;&lt; endl;

      namedWindow("tiltshift", 1);


    for (int i = 0; i &lt; height; ++i)
        {
          for (int j = 0; j &lt; width; ++j)
          {
            p1.at&lt;uchar&gt;(i, j) = alpha(i, d, l1, l2);
          }
        }

        for (int i = 0; i &lt; height; ++i)
        {
          for (int j = 0; j &lt; width; ++j)
          {
            p2.at&lt;uchar&gt;(i, j) = 255 - p1.at&lt;uchar&gt;(i, j);
          }
        }

        cvtColor(p1, p1, CV_GRAY2RGB);
        cvtColor(p2, p2, CV_GRAY2RGB);

    while(true){

      video &gt;&gt; frame;


      for ( int i = 1; i &lt; 9; i = i + 2 )
        {
          medianBlur ( frame, frame_borrado, i );
        }

        multiply(frame, p1, dst1, 1.0, CV_16U);
        multiply(frame_borrado, p2, dst2, 1.0, CV_16U);

        addWeighted(dst1, 1 , dst2, 1, 100.0, resultado);
        imshow("tiltshift", resultado);


      if(waitKey(30) &gt;= 0) break;


    }


    return 0;
  }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>O resultado de um dos frames, apesar da baixa qualidade do vídeo utilizado para o teste, pode ser visto na imagem a seguir:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/Lucianorlneto/lucianorlneto.github.io/master/exercicio%20tiltshiftvideo.png" alt="exercicio%20tiltshiftvideo"></span></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_6_seção_8_filtragem_no_domínio_da_frequência">6. Seção 8: Filtragem no domínio da frequência</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_6_1_exercício">6.1 Exercício</h3>
<div class="paragraph">
<p>Utilizando o programa exemplos/dft.cpp como referência, implemente o filtro homomórfico para melhorar imagens com iluminação irregular. Crie uma cena mal iluminada e ajuste os parâmetros do filtro homomórfico para corrigir a iluminação da melhor forma possível. Assuma que a imagem fornecida é em tons de cinza.</p>
</div>
<div class="sect3">
<h4 id="_resolução_10">Resolução</h4>
<div class="paragraph">
<p>Partindo do programa exemplos/dft.cpp, mencionado na seção 8, como referência, são feitas poucas alterações. O filtro utilizado é um filtro homomórfico, que é caracterizado pela equação abaixo, no lugar do filtro passa-baixas. São adicionados sliders para uma melhor determinação dos parâmetros de entrada para esse filtro e, a cada modificação de um valor dos sliders, é executado o mesmo algortimo do programa exemplo.cpp, porém utilizando uma função que aplica o filtro homomórfico.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/Lucianorlneto/lucianorlneto.github.io/master/homomorficofiltro.png" alt="homomorficofiltro"></span></p>
</div>
<div class="paragraph">
<p>Abaixo pode-se ver o código que aplica o filtro homomórfico com 4 sliders, um para cada parâmetro:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="listingblock">
<div class="title">filtrohomomorfico.cpp</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">  #include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;

using namespace cv;
using namespace std;


char TrackbarName[50];
int gh_slider;
int gh_slider_max = 500;
int gl_slider;
int gl_slider_max = 500;
int c_slider;
int c_slider_max = 500;
int d0_slider;
int d0_slider_max = 500;

Mat imaginaryInput, complexImage, multsp;
  Mat padded, filter, mag, resultado;
  Mat image, imagegray, tmp;
  Mat_&lt;float&gt; realInput, zeros;
  vector&lt;Mat&gt; planos;

   int dft_M, dft_N, M, N;

   float gh, gl, c, d0;

void deslocaDFT(Mat&amp; image ){
  Mat tmp, A, B, C, D;

  image = image(Rect(0, 0, image.cols &amp; -2, image.rows &amp; -2));
  int cx = image.cols/2;
  int cy = image.rows/2;

  A = image(Rect(0, 0, cx, cy));
  B = image(Rect(cx, 0, cx, cy));
  C = image(Rect(0, cy, cx, cy));
  D = image(Rect(cx, cy, cx, cy));

  A.copyTo(tmp);  D.copyTo(A);  tmp.copyTo(D);

  C.copyTo(tmp);  B.copyTo(C);  tmp.copyTo(B);
}


   void filtragem(){
  for(int i=0; i&lt;dft_M; i++){
    for(int j=0; j&lt;dft_N; j++){
        tmp.at&lt;float&gt; (i,j) = (gh-gl)*(1.0-exp(-1.0*(float)c*((((float)i-M/2.0)*((float)i-M/2.0) + ((float)j-N/2.0)*((float)j-N/2.0))/(d0*d0))))+ gl;
    }
  }

  Mat comps[]= {tmp, tmp};
  merge(comps, 2, filter);


    planos.clear();
    realInput = Mat_&lt;float&gt;(padded);
    planos.push_back(realInput);
    planos.push_back(zeros);

    merge(planos, complexImage);



    dft(complexImage, complexImage);

    deslocaDFT(complexImage);

    mulSpectrums(complexImage,filter,complexImage,0);

    planos.clear();
    split(complexImage, planos);

    merge(planos, complexImage);

    deslocaDFT(complexImage);

    idft(complexImage, complexImage);


    planos.clear();

    split(complexImage, planos);

    normalize(planos[0], planos[0], 0, 1, CV_MINMAX);

    imshow("original", image);
    resultado = planos[0].clone();
    imshow("homomorfico", resultado);
   }

   void on_trackbar_gh(int, void*){
	gh = (float)gh_slider*0.1;

	filtragem();
}

void on_trackbar_gl(int, void*){
  gl = (float)gl_slider*0.1;

  filtragem();
}

void on_trackbar_c(int, void*){
  c = (float)c_slider*0.1;

  filtragem();
}

void on_trackbar_d0(int, void*){
  d0 = (float)d0_slider*0.1;

  filtragem();
}


int main(int , char**){

  image = imread("controle.png",CV_LOAD_IMAGE_GRAYSCALE);

  namedWindow("settings", WINDOW_NORMAL);
  namedWindow("original", WINDOW_NORMAL);
  namedWindow("homomorfico", WINDOW_NORMAL);




  dft_M = getOptimalDFTSize(image.rows);
  dft_N = getOptimalDFTSize(image.cols);

  copyMakeBorder(image, padded, 0,
                 dft_M - image.rows, 0,
                 dft_N - image.cols,
                 BORDER_CONSTANT, Scalar::all(0));

  zeros = Mat_&lt;float&gt;::zeros(padded.size());

  complexImage = Mat(padded.size(), CV_32FC2, Scalar(0));

  filter = complexImage.clone();

  tmp = Mat(dft_M, dft_N, CV_32F);


  M=dft_M;
  N=dft_N;


  sprintf( TrackbarName, "gh x %d", gh_slider_max );
  createTrackbar( TrackbarName, "settings",
          &amp;gh_slider,
          gh_slider_max,
          on_trackbar_gh );
  on_trackbar_gh(gh_slider, 0 );
  sprintf( TrackbarName, "gl x %d", gl_slider_max );
  createTrackbar( TrackbarName, "settings",
          &amp;gl_slider,
          gl_slider_max,
          on_trackbar_gl );
  on_trackbar_gl(gl_slider, 0 );
  sprintf( TrackbarName, "c x %d", c_slider_max );
  createTrackbar( TrackbarName, "settings",
          &amp;c_slider,
          c_slider_max,
          on_trackbar_c );
  on_trackbar_c(c_slider, 0 );
  sprintf( TrackbarName, "d0 x %d", d0_slider_max );
  createTrackbar( TrackbarName, "settings",
          &amp;d0_slider,
          d0_slider_max,
          on_trackbar_d0 );
  on_trackbar_d0(d0_slider, 0 );

    waitKey(0);

    imwrite("imagem_resultado.png", resultado);

  return 0;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>O resultado pode ser visto nas imagens abaixo:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/Lucianorlneto/lucianorlneto.github.io/master/exercicio%208.1%20settings_homomorfico.png" alt="exercicio%208.1%20settings homomorfico"></span>
<span class="image"><img src="https://raw.githubusercontent.com/Lucianorlneto/lucianorlneto.github.io/master/exercicio%208.1%20controle_original.png" alt="exercicio%208.1%20controle original"></span>
<span class="image"><img src="https://raw.githubusercontent.com/Lucianorlneto/lucianorlneto.github.io/master/exercicio%208.1%20controle_homomorfico.png" alt="exercicio%208.1%20controle homomorfico"></span></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_7_seção_11_canny_e_a_arte_com_pontilhismo">7. Seção 11: Canny e a arte com pontilhismo</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_7_1_exercício">7.1 Exercício</h3>
<div class="ulist">
<ul>
<li>
<p>Utilizando os programas exemplos/canny.cpp e exemplos/pontilhismo.cpp como referência, implemente um programa cannypoints.cpp. A idéia é usar as bordas produzidas pelo algoritmo de Canny para melhorar a qualidade da imagem pontilhista gerada. A forma como a informação de borda será usada é livre. Entretanto, são apresentadas algumas sugestões de técnicas que poderiam ser utilizadas:<br></p>
<div class="ulist">
<ul>
<li>
<p>Desenhar pontos grandes na imagem pontilhista básica;+</p>
</li>
<li>
<p>Usar a posição dos pixels de borda encontrados pelo algoritmo de Canny para desenhar pontos nos respectivos locais na imagem gerada;+</p>
</li>
<li>
<p>Experimente ir aumentando os limiares do algoritmo de Canny e, para cada novo par de limiares, desenhar círculos cada vez menores nas posições encontradas. A Figura Pontilhismo aplicado à imagem Lena foi desenvolvida usando essa técnica;<br></p>
</li>
</ul>
</div>
</li>
<li>
<p>Escolha uma imagem de seu gosto e aplique a técnica que você desenvolveu.<br></p>
</li>
<li>
<p>Descreva no seu relatório detalhes do procedimento usado para criar sua técnica pontilhista.<br></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_resolução_11">Resolução</h4>
<div class="paragraph">
<p>Para executar o pontilhismo com canny, foi necessário utilizar os dois códigos presentes na pergunta como referência. Primeiro é feita a técnica do pontilhismo utilizando parâmetros provindos de 3 sliders, que passam os valores STEP, JITTER e RAIO, que dão as características da técnica de pontilhismo. Após produzida a imagem com a técnica de pontilhismo, é executado o algoritmo de canny em um loop de 5 iterações na imagem original com um limiar inicial determinado por um slider e o raio dos círculos iniciando em 1 onde, a cada iteração do loop, o limiar é multiplicado por 2 e o raio somado em 1, fazendo com que, em cima da primeira imagem gerada com a técnica de pontilhismo, sejam gerados outros círculos que seguem as bordas da imagem gerada pelo algoritmo de canny de forma que, para bordas mais marcantes (limiares maiores), os círculos sejam maiores que os de bordas que caracterizam textura, por exemplo, fazendo com que sejam gerados circulos cada vez maiores para bordas mais significativas da imagem. Os limiares do algortimo de canny são, sendo um maior que o outro, o maior sendo duaz vezes o menor.</p>
</div>
<div class="paragraph">
<p>Abaixo é possível ver o código do programa:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="listingblock">
<div class="title">cannyp.cpp</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;

using namespace std;
using namespace cv;


vector&lt;int&gt; yrange;
  vector&lt;int&gt; xrange;

  Mat image, frame, points, border;

  int width, height;
  int x, y, l, r;

  Vec3b val;

  char TrackbarName[50];
int step_slider = 10;
int step_slider_max = 30;
int jitter_slider = 5;
int jitter_slider_max = 30;
int raio_slider = 5;
int raio_slider_max = 30;
int limiar_slider = 5;
int limiar_slider_max = 30;

  int STEP, JITTER, RAIO;

  void final(){
    xrange.resize(height/STEP);
  yrange.resize(width/STEP);

  iota(xrange.begin(), xrange.end(), 0);
  iota(yrange.begin(), yrange.end(), 0);

  for(uint i=0; i&lt;xrange.size(); i++){
    xrange[i]= xrange[i]*STEP+STEP/2;
  }

  for(uint i=0; i&lt;yrange.size(); i++){
    yrange[i]= yrange[i]*STEP+STEP/2;
  }

  points = Mat(height, width, CV_8UC3, Scalar(255, 255, 255));

  random_shuffle(xrange.begin(), xrange.end());

  for(auto i : xrange){
    random_shuffle(yrange.begin(), yrange.end());
    for(auto j : yrange){
      x = i+rand()%(2*JITTER)-JITTER+1;
      y = j+rand()%(2*JITTER)-JITTER+1;
      val = image.at&lt;Vec3b&gt;(x,y);
      circle(points,
             cv::Point(y,x),
             RAIO,
             CV_RGB(val[2],val[1],val[0]),
             -1,
             CV_AA);
    }
  }

  imshow("pontilhismo", points);


  r = 1;

  for(int a=0; a&lt;5; a++){
    Canny(image, border, l, 2*l);
    l=l*2;
    for(int i=1; i&lt;height; i++){
      for(int j=1; j&lt;width; j++){
        if(border.at&lt;uchar&gt;(i,j) == 255){
          val = image.at&lt;Vec3b&gt;(i,j);
          circle(points,
                 cv::Point(j,i),
                 r,
                 CV_RGB(val[2],val[1],val[0]),
                 -1,
                 CV_AA);
        }
      }
    }
    r=r+1;
  }

  imshow("pontilhismo com canny", points);
  imshow("canny", border);
  }

  void on_trackbar_step(int, void*){
  STEP = step_slider;

  final();
}

void on_trackbar_jitter(int, void*){
  JITTER = jitter_slider;

  final();
}

void on_trackbar_raio(int, void*){
  RAIO = raio_slider;

  final();
}

void on_trackbar_limiar(int, void*){
  l = limiar_slider;

  final();
}

int main(int argc, char** argv){

  l = 10;
  STEP = 2;
  JITTER = 2;
  RAIO = 2;

  image= imread(argv[1],CV_LOAD_IMAGE_COLOR);

  namedWindow("pontilhismo com canny", WINDOW_NORMAL);
  namedWindow("pontilhismo", WINDOW_NORMAL);
  namedWindow("canny", WINDOW_NORMAL);
  namedWindow("settings", WINDOW_NORMAL);

  srand(time(0));

  if(!image.data){
  cout &lt;&lt; "nao abriu " &lt;&lt; argv[1] &lt;&lt; endl;
    cout &lt;&lt; argv[0] &lt;&lt; " imagem.jpg";
    exit(0);
  }

  width=image.size().width;
  height=image.size().height;

  sprintf( TrackbarName, "step x %d", step_slider_max );
  createTrackbar( TrackbarName, "settings",
          &amp;step_slider,
          step_slider_max,
          on_trackbar_step );
  on_trackbar_step(step_slider, 0 );
  sprintf( TrackbarName, "jitter x %d", jitter_slider_max );
  createTrackbar( TrackbarName, "settings",
          &amp;jitter_slider,
          jitter_slider_max,
          on_trackbar_jitter );
  on_trackbar_jitter(jitter_slider, 0 );
  sprintf( TrackbarName, "raio x %d", raio_slider_max );
  createTrackbar( TrackbarName, "settings",
          &amp;raio_slider,
          raio_slider_max,
          on_trackbar_raio );
  on_trackbar_raio(raio_slider, 0 );
  sprintf( TrackbarName, "limiar x %d", limiar_slider_max );
  createTrackbar( TrackbarName, "settings",
          &amp;limiar_slider,
          limiar_slider_max,
          on_trackbar_limiar );
  on_trackbar_limiar(limiar_slider, 0 );

  final();


  waitKey(0);

  imwrite("pontilhismo_canny.jpg", points);

  return 0;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Os resultados do algoritmo podem ser vistos nas imagens a seguir, onde temos a imagem original, o as imagens geradas enquanto o algortimo é executado e a imagem final de forma que seja melhor de enxergar as alterações do que na imagem do programa sendo executado.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/Lucianorlneto/lucianorlneto.github.io/master/mx.jpg" alt="mx"></span>
<span class="image"><img src="https://raw.githubusercontent.com/Lucianorlneto/lucianorlneto.github.io/master/exercicio%2011.1%20cannypontilhismo.png" alt="exercicio%2011.1%20cannypontilhismo"></span>
<span class="image"><img src="https://raw.githubusercontent.com/Lucianorlneto/lucianorlneto.github.io/master/exercicio%2011.1%20pontilhismo_canny.jpg" alt="exercicio%2011.1%20pontilhismo canny"></span></p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2017-05-12 01:14:56 BRT
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>
</body>
</html>